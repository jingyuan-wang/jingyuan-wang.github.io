
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>Tough·Works</title>
	<meta name="author" content="Jingyuan Wang">

	
	<meta name="description" content="关于验收测试的剖析 原文地址：https://gojko.net/2010/06/16/anatomy-of-a-good-acceptance-test/ 作者：Gojko Adzic 敏捷验收测试的长期收益来自于活文档——它是一份系统功能的描述文档，可靠，易于访问，并且比代码更容易阅读和理解 &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="" rel="alternate" title="Tough·Works" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async="true" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">Tough·Works</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:jingyuan-wang.github.io">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
    
		
		
		
		
		
    
	</div>
	<form class="search" action="https://www.google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:jingyuan-wang.github.io">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/04/18/acceptance-test-anatomy/">
		
			Acceptance Test Anatomy</a>
	</h2>
	<div class="entry-content">
		<h1 id="section">关于验收测试的剖析</h1>

<p>原文地址：<a href="https://gojko.net/2010/06/16/anatomy-of-a-good-acceptance-test/">https://gojko.net/2010/06/16/anatomy-of-a-good-acceptance-test/</a></p>

<p>作者：Gojko Adzic</p>

<p>敏捷验收测试的长期收益来自于<strong>活文档</strong>——它是一份系统功能的描述文档，可靠，易于访问，并且比代码更容易阅读和理解。为了能够成为有效的、活的规范说明，验收测试必须以这样一种方式写作——<strong>能够让他人在几个月甚至几年以后，轻易地明白他们在做什么，为什么做以及具体的描述是什么</strong>。这里有一些简单的启发式方法，可以帮助你度量和改进测试，使其更好地成为一份活的规范说明。</p>

<p>需要思考的五个最重要的点是：</p>

<ul>
  <li>它必须是自解释的 （self explanatory）</li>
  <li>它必须要聚焦</li>
  <li>它必须是一个具体描述，而不是脚本</li>
  <li>它必须使用领域语言</li>
  <li>它必须是关于业务功能，而不是软件设计</li>
</ul>

<p>这里有一个很好的例子：</p>

<p><img src="https://gojko.net/assets/offer2.png" alt="figure 1" /></p>

<p>它具备了上边列出的所有要素。每当我在工作坊向人们展示这个例子时，我都不需要解释一个字。它的标题和介绍段落清晰地说明了测试数据的结构，足以让读者不需要回到数据中去了解规则。而下方那些例子则使之变得实际可测，并解释了边缘情况下的行为。并且，它聚焦在<em>免费送货的有效性</em>的这个非常特殊的规则上，没有解释要如何购买这些书，而仅仅只是专注于可用的交付机制是什么，也没有尝试谈论任何实现的细节。</p>

<p>这里也有一个非常糟糕的案例（取自于旧的FitNesse用户指南）：</p>

<p><img src="https://gojko.net/assets/bad_example_acceptance_test.png" alt="figure 2" /></p>

<p>这个测试写得如此糟糕，以至于它某种意义上反而成为了一个很好的例子，用来说明当人们对写好测试漠不关心时，会发生什么。</p>

<p>首先，虽然它有一个标题，和一些围绕表格的说明文字，看起来像是解释发生了什么，但是结果差强人意。为什么说这个测试简单？工资单检查到底检查什么？在“自解释”的石蕊试验中，它彻底失败了。(译注：石蕊试验是利用石蕊检验酸碱度的古老检验方式。现在经常被用于比喻一种立见分晓的检验方法。)</p>

<p>其次，这个测试到底核查了什么完全不清楚。我们不得不回退。它似乎是在验证支票是以唯一的数字打印的，这个数字是从系统中可配置的下一个可用的数字开始。也似乎是在校验每张支票上所打印的数据。而且每个员工打印一张支票（稍后再回到这里）。</p>

<p>这里有很多看似偶然的复杂性——名称和地址这两项数据，除了在建立员工之外，整个测试中的任何地方都没有使用过。还有一些与业务规则完全无关的数据库编号，用于匹配员工和工资检查器。</p>

<p>工资检查器很显然只是为了测试而造的。没有哪个公司会派一身Clouseau装备的Peter Sellers（译注：作者这里的引用来自于经典电影<em>粉红豹</em>系列，Peter Sellers在片中长期扮演了脍炙人口的角色Clouseau检察官。）在那儿一张张的检查支票。如果你有大量的员工，不得不打印支票，你当然不会想要手动检查。那么这正是这个测试的关键。</p>

<p>在测试的断言部分还有一个非常有趣的空白单元格问题，以及两个看似无关联的工资检查表。FitNesse的空白单元格用于打印测试结果进行调试和故障排除，但是不检查任何内容。所以这是一个必须要人工检查的自动化测试——这几乎推翻了自动化的目的。在测试中，空白格通常是不稳定性的一个迹象（稍后将更详细说明这点），它们往往是一个信号，说明你漏了些什么——要么测错了地方，要么就是缺少某个规则，使得整个系统过程可重复并且可测试。</p>

<p>这种语言是不一致的，这使得一开始很难在输入和输出之间建立连接。最下面表格中的1001值是什么东西？表头告诉我们这是一个数字——谢天谢地，我以为那是一根香肠。上面的表格中有一个“支票号码”，但是是什么样的支票号码？这两件事情之间有什么关联？</p>

<p>所以这个测试写的真的是一塌糊涂。</p>

<p>假设地址信息存在是因为打印的支票是结算清单的一部分，有了地址信息，结算清单就可以进行自动化的信封包装，这个测试还是至少漏查了一件非常重要的事情：那就是对的人拿到了对的工资金额。如果第一个人得到了两张支票，这条测试会愉快地通过。如果两个人互相拿到了对方的薪水，这条测试同样也会通过。如果印在支票上的日期是在遥远将来的某一天，远到我们的员工可能来不及兑现，这条测试照样还是可以通过。这些单元格空白的原因还隐藏着另一个规则：支票产生的时间顺序。这一点也没有给出任何说明。所以，这种功能缺口的技术修补方案，就是创建一个带给我们大量假阳性结果的测试。</p>

<p>这个测试是要检查一件事还是多件事情？没有上下文信息，我们很难下结论。如果打印支票的系统还有其他的用途，我会提出一个事实，那就是支票号码是唯一的，并且是从一个可配置的数字开始到每一个单独的页面。而即便我们只是用其来打印工资支票，这依然有可能只是一件事情（工资支票打印）的某一部分。</p>

<p>现在，让我们来清理一下。我们试着回溯，并且删掉所有附带的东西。首先，起一个很好的描述性标题，例如“工资支票打印”，然后，添加一个段落来解释测试结构。</p>

<p>一张支票上有收款人姓名，金额和支付日期。支票本身并没有名字和工资。如果支票打印在结算清单上，那么它也会有一个地址，用于自动信封包装。一个名字和地址的组合应该足够让我们将员工与他的支票匹配起来——我们真的不需要数据库的编号信息。通过商定的排序规则，我们可以让整个系统变得更加可测试——不论这个规则是什么，例如，按字母顺序排序。</p>

<p>让我们将场景拉到测试的开始。我们的背景是工资日期、下一个可用的支票号码、以及员工的工资数据。让我们明确阐述一下每个数字分别是什么，这样以后的读者就不用再自己想办法弄清楚。我们还可以让这个区块视觉上突显出来，以表示它是关于上下文的描述。</p>

<p>需要启动的操作并不一定要列在测试中。一次工资的核算运行可以由检查工资单结果的表进行隐式执行。这个例子聚焦的是什么需要被测试，而不是怎么被测试。这里没有必要用一个单独的步骤来说“下一步我们付钱”。</p>

<p>同样，我们也可以将工资检查器重新命名为更好理解的内容。因为我们希望以后不论是谁来执行这个自动化的过程，都能够确保检查了所有打印出来的支票，所以我们把它放在表格标题当中。不然，有人可能会使用子集进行匹配，导致系统打印每张支票两次，而我们却毫不知情。</p>

<p>这是整理过后的版本。</p>

<p><img src="https://gojko.net/assets/fixed_acceptance_test.png" alt="figure 3" /></p>

<p>没有了那些附加的东西，测试变得更容易理解了。那么重点来了。当我们看到这样的测试，没有数据库编号，没有所有不必要的杂乱，我们有了一个非常干净的画面，来回答问题“我们是否还漏了什么？”。有哪些边缘情况可能会破坏这个测试？我们倒不需要在此验证员工数据的有效性，系统的其他部分会完成这个任务。但是，有没有任何一种有效的员工数据可以成为这个测试案例的临界值？我们是不是可以通过数字游戏将结果变得不合逻辑？</p>

<p>有一个很明显的答案——如果员工的工资是0，会发生什么？还是照旧打印支票么？规则里提到的是“每个员工一张支票”——所以那些已经被解雇多年的员工，即使他们已经不再领取工资，还是会收到打印的支票，只不过金额是0而已。如此，我们可以与业务部门展开一次讨论，看是否需要强化一下规则，确保在不必要的情况下，没有支票产生。</p>

<p>FitNesse因为这些残破不堪的测试案例而声名狼藉。Concordion（译注：<a href="http://concordion.org/">Concordion</a>是一种验收测试的框架）由此应运而生。最近的工作坊当中，也有一些人提出使用Given-When-Then结构的<a href="https://cucumber.io/">Cucumber</a>能够更好的预防这些问题的产生。我不这么认为。这跟工具无关——人们有可能使用任何工具来进行这种糟糕的测试设计，同样，他们也可以使用FitNesse做出又好又干净的测试。我认为，指出FitNesse的基础案例如此糟糕的事实，这于事无补，问题的关键不在于工具，而在于我们所付出的过程和精力，必须要让测试变得容易理解。有趣的是，让测试变得干净漂亮花不了太多精力，但是它带来的价值却远远不止如此。</p>

		
		
	</div>


<div class="meta">
	<div class="date">




Apr 18th, 2017</div>
	<div class="tags">

</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/04/18/progressive-estimation-scale/">
		
			Progressive Estimation Scale</a>
	</h2>
	<div class="entry-content">
		<h1 id="section">为什么采用渐进式估算尺</h1>

<p>原文链接：<a href="http://www.yakyma.com/2012/05/why-progressive-estimation-scale-is-so.html">http://www.yakyma.com/2012/05/why-progressive-estimation-scale-is-so.html</a></p>

<p>作者：Alex Yakyma</p>

<p><em>在本文中，我们将会讨论为什么渐进式的估算尺（Progressive Estimation Scale）——例如敏捷团队常用的斐波那契数列，比线性的估算尺更为有效，在为团队衡量backlog的故事的大小时，呈现更多信息。我们将会用到信息理论的一些基本原则来得到结论，同时，也会形成一个针对“归一化的估算基准”的假设。</em></p>

<p>在敏捷方法中，我们常常能看到大家使用“渐进式”估算尺对backlog的故事进行估算。最常见的方法是<em>修正过的斐波那契数列：0, ½, 1, 2, 3, 5, 8, 13, 20, 40, 100</em>。还有一种不太常见的估算尺，是XP（译注：极限编程）的拥护者们所倡导的：<em>0, 1, 2, 4, 拆分</em> （本文中我们且将这种估算尺称为<em>XP尺</em>）。之所以称之为<em>渐进式</em>，就是为了说明，其价值的增长速度比线性增长更快。所以我们常常也会称这类估算尺（虽然通常情况下并不是100%准确）为<em>指数式</em>估算尺。</p>

<p>事实上，XP尺本身就是指数的，而斐波那契数列与函数 $f(x)=1.6^{x-1}$ 次方所定义的范围大致相当。参考下图：</p>

<p><img src="/images/2017/04/Approximating_Fibonacci_with_the_Exponent.png" alt="figure 1" /></p>

<p><em>图1. 修正过的斐波那契数列的的数值范围与指数函数大致相当</em></p>

<p>在这里作此说明的目的，是为了表示这两种估算尺都具有同样程度的精确性，我们称之为“指数级”精确度。</p>

<p>话虽如此，还是让我们先反问自己：为什么要使用指数级的估算尺？众所周知，已经有成千上万的敏捷团队成功地应用了这类估算尺，是什么使得指数尺如此堪以大用？过去，我们面对此类问题，通常的回答是——提出backlog里的故事越大（比如<em>N</em>个故事点），那么说出<em>N</em>和<em>N-1</em>之间的差异就越难。这确实是正确的，然而这个回答本身并不是一个基本的公理，它只是基于一些通用原则的推论。就让我们来看一看这些原则。</p>

<h3 id="section-1">信息理论视角</h3>

<p>让我们换一个角度提出问题，假设我们（非常粗略地）知道backlog里故事<em>U</em>的大小不超过<em>L</em>个单位（可以是故事点，也可以是人·天，在这里这点并不重要），但是它可能是<em>0</em>到<em>L</em>的任意值，并且所有的可能性均等。假设，有一种估算技术，允许我们以<em>P</em>的绝对精确度估算出<em>U</em>的大小，那么我们可以看看，<em>运用这种技术能得到多少关于故事U大小的信息</em>。</p>

<p><img src="/images/2017/04/Estimation_Precision.png" alt="figure 2" /></p>

<p><em>图2. 符号说明：U是backlog里的任意一张故事卡；L是backlog里所有卡片可能大小的最大值；P是估算的绝对精度；横轴上的连着U的点代表故事U的大小。</em></p>

<p>根据<em>信息理论</em>的基础知识我们知道，实验A中关于实验B的信息（也叫两个实验的<em>互信息</em>，详细可参考<a href="https://en.wikipedia.org/wiki/Mutual_information">Wikipedia</a>）可以表示如下：</p>

<script type="math/tex; mode=display">I(A,B) = H(B) - H_A(B)</script>

<p>这里，$H(B)$ 是<em>信息熵</em>，也就是实验B的不确定程度。$H_A(B)$是实验A发生后，实验B的<em>熵</em>（也称为<em>条件熵</em>）。所以现在可以很容易将实验A中包含的的信息量解释为它为实验B所减少的不确定度。</p>

<p>现在，让我们把这个公式应用于我们的案例。我们也有两个“实验”，实验 <em>(B)</em> 是确定故事U的准确大小，实验 <em>(A)</em> 是应用我们的估算技术，从而在一定程度上减少不确定度（例如，获得一些信息）。避免展开数学深度的计算，这里我们仅需注意到，通过应用<em>香农定律</em>（实际上是互信息的一种定义），我们可以得到：</p>

<script type="math/tex; mode=display">I(A,B) = log(L/P)</script>

<p>这里对数的底数并不是非常重要，它可以是符合对数简单特征（参考<a href="https://en.wikipedia.org/wiki/Logarithm#Change_of_base">Wikipedia</a>）的任意数量（大于<em>1</em>），但是通常人们会使用2作为底数，从计算机的角度来看，这倒是非常有意义，因为最终我们所有的信息都是以<em>二进制</em>形式存储的。</p>

<p>后面这个方程给出了一个非常有意思的结果：相比估算精度的提升，我们通过估算获得信息量的提升要慢得多。更具体地说，它是一个对数函数式的增长。通过下图这个对数函数图，我们就可以看出为什么“少量的估算事半功倍，而大量的估算事倍功半。”</p>

<p><img src="/images/2017/04/logarithm.png" alt="logarithm" /></p>

<p><em>图3. <code>故事大小的信息</code>的对数行为，可作为估算过程的结果。横轴代表相对精度（或者更精确的说，代表了(L/P)的值），纵轴代表信息量（以比特计）。</em></p>

<p>所以最终，使用指数（或近指数）估算尺就变得非常合乎逻辑了——<strong>有价值的信息增加得更快</strong>。确实，任意函数 $f(x)=a^{log_bx}$ 的增长肯定比 $log_bx$ 自身要快(a和b都大于1）。在理想环境下——现实中我们一定不会做此期待，当 $a=b$ 时，这个函数就变成了线性函数：$f(x) = x$。但是既然我们不会去声明这是必须的条件，那么我们通常就会说“信息增加得更快”，而不是“线性增加信息”。</p>

<h3 id="section-2">归一化假设</h3>

<p>另一个有趣的问题是，考虑到大多数团队都在使用斐波那契数列作为估算尺，他们是怎么确保他们“校正后的信息曲线”（例如，函数 $f(x)=a^{log_bx}$ 对应的曲线）能够增长得更快，从而使其比线性尺更加有用呢？显然，“信息曲线”的对数行为是可以肯定的，但是，如何在实际中找到确切的对数底数却不是件容易的事。虽说我们可以寄希望于团队通过自身经验能够找到斐波那契数列的正确用法，从而有效地获得信息。那么，什么是“正确用法”呢？</p>

<p>为了进一步简化分析（如前文所作的分析），我们可以使用某些指数函数，而不是斐波那契数列。即便底数是固定的（例如，$f(x)=a^x$ ），我们的团队还是可以改变函数本身，通过什么方式呢？对，正是“重新调节故事点”。确实，如果我们赋予故事点新的含义，比如说，以前的2个故事点等于现在的1个故事点，那我们的函数 $f(x)$ 变成了新的函数 $g(t)=f(2x)$ , 其中 $t=2x$ 。或者反过来，$x=0.5t$。如果我们替换掉前面公式中的$x$，我们可以得到 $g(t)=b^t$ ，其中 $b$ 是 $a$ 的平方根。新的函数 $g(t)$ 又成了一个指数函数，只是底数不同而已。下图这个例子，说明了重新调节故事点所产生的影响——如果我们将以前的3个故事点变为现在的2个故事点的大小，那么“估算尺曲线”会产生什么样的变化呢？</p>

<p><img src="/images/2017/04/Rescaling_the_estimation_base.png" alt="figure 4" /></p>

<p><em>图4. 重新调节故事点——将原本的3个故事点变成新的2个故事点之后，指数函数（估算函数）的底数也随之改变。图中蓝线代表原来的估算尺，红线代表新的估算尺。</em></p>

<p>这就说明:</p>

<blockquote>
  <p>不断改变斐波那契数列的估算基础是一件非常有责任的事情，而这一点往往被低估。它可以让团队更趋高效的估算，当然，也有可能背道而驰。理想的估算底数只有一个，保证离它越来越近是很至关重要的。</p>
</blockquote>

<p>现在，我们可以看看一个有趣的事实，也就是许多敏捷团队都可以确认的：</p>

<blockquote>
  <p>经过一段时间之后，敏捷团队常常会“归一”，到达一个近似于斐波那契数列的估算底数——在一个两周的sprint内，团队的平均速度通常为30-60个故事点。</p>
</blockquote>

<p>当然，这也取决于团队规模，团队越小，这个数字越小；团队越大，数字也会越大。但也可能，这是团队为了更有效地管理潜在的可用信息，随着时间推移，不断优化其估算底数后的结果。基于此，我们也形成了我们的……</p>

<blockquote>
  <p><strong>归一化假设</strong>：那些随着时间推移，使其估算基准归一化的团队，很大可能已经到达了他们的最佳估算能力（从他们估算过的，backlog里的项目所获得的信息的角度来看）。换言之，他们经验性的发现了这个指数函数，使得“矫正后的信息曲线”接近线性。</p>
</blockquote>

<p>虽然看起来，要到达一个更好的估算基准，会有一段距离，但我们有了一个简单蠢笨但是可靠的方法作为开始。简单地在一个<em>sprint</em>给每个队员分配<em>8</em>个故事点，不是一个糟糕的初始估计值。事实上，考虑到上面的假设，当团队成员<em>N</em>从<em>4</em>到<em>8</em>变化时，我们得到的故事点$N×8$正好从<em>32</em>到<em>64</em>变化不等。</p>

<p>想要了解更多估算基准，可以参考 （<a href="http://www.amazon.com/Agile-Software-Requirements-Enterprise-Development/dp/0321635841">Agile Software Requirements Enterprise Development</a> 第八章，敏捷估算和速率）</p>

		
		
	</div>


<div class="meta">
	<div class="date">




Apr 18th, 2017</div>
	<div class="tags">

</div>
	
</div>
</article>

<nav id="pagenavi">
    
        
            <a href="/" class="prev">Prev</a>
        
    
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav>
</div>
	<footer id="footer" class="inner">Copyright &copy; 2018

    Jingyuan Wang

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->






</body>
</html>